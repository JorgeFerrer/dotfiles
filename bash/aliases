# Ant

alias aa="ant -Dlint.failonerror=false all"

# System aliases

alias mlog="tail -f /var/log/mail.log"
alias pfs="sudo postfix start"

# Utility

function dotfilespath {
	dirname $(resolve "$HOME/.bash_profile")
}

function resolve {
	[ ! -h "$1" ] && echo "$1" || (local link="$(expr "$(command ls -ld -- "$1")" : '.*-> \(.*\)$')"; cd $(dirname $1); resolve "$link" | sed "s|^\([^/].*\)\$|$(dirname $1)/\1|");
}

function reload {
	dotfiles="$(dotfilespath)"
	install_script="${dotfiles}/install.sh"

	if [[ -d "$dotfiles" && -f "$install_script" ]]; then
		$install_script
	fi
}

alias sbp='source ~/.bash_profile'

# Tar
alias tx="tar -xvzf"
alias tb="tar -cvjf"

# Processes
alias tu="top -o cpu" # cpu
alias tm="top -o vsize" # memory

# Git
alias gs="git status"
alias gitk="/usr/bin/wish $(which gitk)"

# Alias "g" to "git" command, but preserving git-completion
alias g="git"
complete -o default -o nospace -F _git g

# Alias gh to git help
alias gh="git help"

function mygithelp {
	local cur
	_get_comp_words_by_ref -n =: cur
	__git_compute_porcelain_commands
	__gitcomp "$__git_porcelain_commands $(__git_aliases)"
}

complete -o default -o nospace -F mygithelp gh

# MySQL
function mysqlexec {
	mysql -u root -p -e "$1";
}

function createdb {
	mysqlexec "create database \`$1\` CHARACTER SET utf8;";
}

function dropdb {
	mysqlexec "drop database if exists \`$1\`;";
}

function cleardb {
	mysqlexec "drop database if exists \`$1\`; create database \`$1\`
CHARACTER SET utf8;"
}

function git_track() {
	echo "\n[branch \"$1\"]\n\tremote = origin\n\tmerge = refs/heads/$1" >> ".git/config"
}

# Navigation

function cdl {
	cd $1;
	ls -l
}

function upl {
	cdl ..
}

# Move up N levels of the directory tree
# Or by typing in some dir in the PWD
# eg. Assuming your PWD is "/Volumes/Users/natecavanaugh/Documents/stuff"
# 	  `up 2` moves up 2 directories to "/Volumes/Users/natecavanaugh"
#	  `up 2/` and pressing tab will autocomplete the dirs in "/Volumes/Users/natecavanaugh"
#	  `up Users` navigate to "/Volumes/Users"
#	  `up us` and pressing tab will autocomplete to "/Volumes/Users"
function up {
	dir="../"
	if [ -n "$1" ]; then
		if [[ $1 =~ ^[0-9]+$ ]]; then
			strpath=$( printf "%${1}s" );
			dir=" ${strpath// /$dir}"
		else
			dir=${PWD%/$1/*}/$1
		fi
	fi

	cd $dir
}

function _get_up {
	local cur
	local dir
	local results
	COMPREPLY=()
	#Variable to hold the current word
	cur="${COMP_WORDS[COMP_CWORD]}"

	local lower_cur=`echo ${cur##*/} | tr [:upper:] [:lower:]`

	# Is the arg a number or number followed by a slash
	if [[ $cur =~ ^[0-9]+/? ]]; then
		dir="../"
		strpath=$( printf "%${cur%%/*}s" );
		dir=" ${strpath// /$dir}"

		# Is the arg just a number?
		if [[ $cur =~ ^[0-9]+$ ]]; then
			COMPREPLY=($(compgen -W "${dir}"))
		else
			if [[ $cur =~ /.*$ ]]; then
				cur="${cur##*/}"
			fi

			results=$(for t in `cd $dir && ls -d */`; do if [[ `echo $t | tr [:upper:] [:lower:]` == "$lower_cur"* ]]; then echo "${t}"; fi done)

			COMPREPLY=($(compgen -P "$dir" -W "${results}"))
			# COMPREPLY=($(compgen -P "$dir" -W "${results}" $cur))
		fi
	else
		# Is the arg a word that we can look for in the PWD
		results=""
		cur_pwd=${PWD%/*}

		for t in `echo $cur_pwd | tr "/" "\n"`; do
			if [[ `echo $t | tr [:upper:] [:lower:]` == "$lower_cur"* ]]; then
				results="$results ${t}";
			fi
		done

		COMPREPLY=($(compgen -W "${results}"))
	fi	
}

#Assign the auto-completion function _get for our command get.
complete -F _get_up up

function le {
	perl -p -e 's[\r\n][WIN\n]; s[(?<!WIN)\n][UNIX\n]; s[\r][MAC\n];' ${1:-*}
}

function showle {
	perl -p -e 's[\r\n][\\r\\n\n]; s[(?<!WIN)\n][\\n\n]; s[\r][\\r\n];' ${1:-*}
}

# Process finder
# @argument name of process
function pf {
	ps ax | grep "$1" | grep -v grep | awk '{ print $1 }'
}

# Process killer
# @argument name of process
function pfkill {
	pf $1 | xargs kill -9
	#ps -ef | grep PROCESS | grep -v grep | awk '{print $2}' | xargs kill -9
}

# Kill java :(
function pfkj {
	pfkill "java"
}

# Simpler grep
# @argument (optional) path
function gr {
	grep -R "$1" "${2:-.}"
	# echo $1 ${2:.}
}

# Set up simple server
function server () {
  open "http://localhost:${1}" && python -m SimpleHTTPServer $1;
}

# Personal

LS_COMMAND="lsc"

if [[ $IS_CYGWIN ]]; then
	LS_COMMAND="ls"
fi

alias ls='$LS_COMMAND --color=tty'     #set the color settings on in the color ls program
alias l='$LS_COMMAND --color=tty -lg'

# -- Paths

alias dotfiles='cd $(dirname $(resolve "$HOME/.bash_profile"))'

# Volume paths
alias vde='cd $NC_DEV_PATH;'
alias vda='cd $NC_DATA_PATH;'

# Liferay paths
alias ,ld='cd $NC_TRUNK_DEV_PATH;'
alias lde=,ld
alias ,lp='cd ${NC_TRUNK_PORTAL_PATH};'
alias ,lpw='cd ${NC_TRUNK_PORTAL_PATH}/portal-web;'
alias ,lpi='cd ${NC_TRUNK_PORTAL_PATH}/portal-impl;'
alias ,lph='cd ${NC_TRUNK_PW_HTML_PATH};'
alias ,lpt='cd ${NC_TRUNK_PW_HTML_PATH}/themes;'
alias ,lpj='cd ${NC_TRUNK_PW_HTML_PATH}/js/liferay;'
alias ,lpc='cd ${NC_TRUNK_PW_HTML_PATH}/portal/css;'

alias l60='cd $NC_BRANCHES_PATH/6.0.x;'
alias l60p='cd $NC_BRANCHES_PATH/6.0.x/portal;'

alias l61='cd $NC_BRANCHES_PATH/6.1.x;'
alias l61p='cd $NC_BRANCHES_PATH/6.1.x/portal;'

alias l52='cd $NC_BRANCHES_PATH/5.2.x;'
alias l5p='cd $NC_BRANCHES_PATH/5.2.x/portal;'

# Alloy paths
alias aui='cd $NC_ALLOY_PATH;'
alias aui1='cd $NC_ALLOY_EE1_PATH;'
alias aui15='cd $NC_ALLOY_EE15_PATH;'

alias myg='cd $NC_GIT_HOME;'

alias auibuild='cd ${NC_ALLOY_PATH}/build'
alias auidemos='cd ${NC_ALLOY_PATH}/demos'
alias auisrc='cd ${NC_ALLOY_PATH}/src'

alias cbin='cd $NC_BIN_PATH'

# -- Commands

# Ant
alias aa='ant all'
alias ad='ant deploy'
alias acd='ant clean deploy'
alias abt='ant build-themes'
alias abm='ant build-modules'
alias abs='ant build-skins'
alias abm='ant build-modules'
alias abaf='ant build-alloy'
alias aba='touch -c third-party/alloy-1.0.1.zip && abaf'

# Misc

# Search history
alias hs="history|grep"

# QuickLook file
alias qlf='qlmanage -p "$@" >& /dev/null'

# Find file by name
alias fn='find . -name '

# Shortcut to SublimeText 2 cli
alias so='~/Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl'

# Replace Sublime icon
alias subicon='sudo cp ~/Documents/Sublime\ Text\ 2.icns  ~/Applications/Sublime\ Text\ 2.app/Contents/Resources/'


# Functions

# Extract Git commit ID from generated alloy zip
# @argument path to zip
function az {
	if [[ ! $1 =~ '.zip'$ ]]; then
		echo "This command only works with zip files :)"
		return 1;
	fi

	delfile=0

	name=$1
	if [[ $1 == *:* ]]; then
		treeish=$1
		name="/tmp/alloy_${RANDOM}.zip"
		delfile=1
		git show -p $treeish > $name
	fi

	unzip -z $name;
	
	[[ $delfile == 1 ]] && rm $name;
}

function auis_impl {
	cd $1;
	git log -1 --format="%h" | tr -d '\n'
}

function auis () {
	auis_impl ${NC_ALLOY_PATH}
}

function auisee () {
	auis_impl ${NC_ALLOY_EE1_PATH}
}

function auic () {
	sha=$(auis)
	echo $sha | tr -d '\n' | pbcopy && echo "Copied $sha to clipboard."
}

function auicee () {
	sha=$(auisee)
	echo $sha | tr -d '\n' | pbcopy && echo "Copied $sha to clipboard."
}

# Get Last JIRA ID from the 
function jid {
	git log -1 --oneline | grep -Eo "([A-Z]{3,}-)([0-9]+)"
}

function mjid {
	echo "`jid` - ${1:-Source formatting}"
}

function jspfcss () {
	cd "${NC_TRUNK_PW_HTML_PATH}/portal/css";
	filelist=''
	for f in `ls -R | grep -E '.jspf'`; do 
		filelist="$filelist '$f',";
	done
	echo $filelist
}